// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: base.proto

package media

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/gogo/protobuf/types"

import time "time"

import strconv "strconv"

import strings "strings"
import reflect "reflect"

import types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// Sắp xếp theo chiều nào
type Pagination_Direction int32

const (
	ASC  Pagination_Direction = 0
	DESC Pagination_Direction = 1
)

var Pagination_Direction_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}
var Pagination_Direction_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (Pagination_Direction) EnumDescriptor() ([]byte, []int) { return fileDescriptorBase, []int{2, 0} }

// Request không có tham số
type EmptyRequest struct {
}

func (m *EmptyRequest) Reset()                    { *m = EmptyRequest{} }
func (*EmptyRequest) ProtoMessage()               {}
func (*EmptyRequest) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{0} }

// Response với mã trạng thái
type ResultResponse struct {
	// Kết quả trả về
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Thông báo lỗi
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ResultResponse) Reset()                    { *m = ResultResponse{} }
func (*ResultResponse) ProtoMessage()               {}
func (*ResultResponse) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{1} }

func (m *ResultResponse) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

func (m *ResultResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Thông tin phân trang
type Pagination struct {
	// Danh sách các cột cần lấy
	Columns []string `protobuf:"bytes,1,rep,name=columns" json:"columns,omitempty"`
	// Sắp xếp theo cột nào
	OrderByColumn    string               `protobuf:"bytes,2,opt,name=order_by_column,json=orderByColumn,proto3" json:"order_by_column,omitempty"`
	OrderByDirection Pagination_Direction `protobuf:"varint,3,opt,name=order_by_direction,json=orderByDirection,proto3,enum=media.Pagination_Direction" json:"order_by_direction,omitempty"`
	// Trang hiện tại
	CurrentPage int32 `protobuf:"varint,4,opt,name=current_page,json=currentPage,proto3" json:"current_page,omitempty"`
}

func (m *Pagination) Reset()                    { *m = Pagination{} }
func (*Pagination) ProtoMessage()               {}
func (*Pagination) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{2} }

func (m *Pagination) GetColumns() []string {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *Pagination) GetOrderByColumn() string {
	if m != nil {
		return m.OrderByColumn
	}
	return ""
}

func (m *Pagination) GetOrderByDirection() Pagination_Direction {
	if m != nil {
		return m.OrderByDirection
	}
	return ASC
}

func (m *Pagination) GetCurrentPage() int32 {
	if m != nil {
		return m.CurrentPage
	}
	return 0
}

type Image struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Link
	Link string `protobuf:"bytes,2,opt,name=link,proto3" json:"link,omitempty"`
	// Type
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	// Ngày tài khoản được tạo
	UploadAt time.Time `protobuf:"bytes,4,opt,name=upload_at,json=uploadAt,stdtime" json:"upload_at" sql:"default:now()"`
	// Id người tạo tài khoản, Null là người dùng tự đăng ký tài khoản
	UploadBy string `protobuf:"bytes,5,opt,name=upload_by,json=uploadBy,proto3" json:"upload_by,omitempty"`
	// Ngày gần nhất tài khoản cập nhật thông tin
	ModifiedAt time.Time `protobuf:"bytes,6,opt,name=modified_at,json=modifiedAt,stdtime" json:"modified_at" sql:"default:now()"`
	// Người cập nhật thông tin tài khoản gần nhất
	ModifiedBy string `protobuf:"bytes,7,opt,name=modified_by,json=modifiedBy,proto3" json:"modified_by,omitempty"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{3} }

func (m *Image) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Image) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *Image) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Image) GetUploadAt() time.Time {
	if m != nil {
		return m.UploadAt
	}
	return time.Time{}
}

func (m *Image) GetUploadBy() string {
	if m != nil {
		return m.UploadBy
	}
	return ""
}

func (m *Image) GetModifiedAt() time.Time {
	if m != nil {
		return m.ModifiedAt
	}
	return time.Time{}
}

func (m *Image) GetModifiedBy() string {
	if m != nil {
		return m.ModifiedBy
	}
	return ""
}

type File struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Link
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Type
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	// Ngày tài khoản được tạo
	UploadAt time.Time `protobuf:"bytes,4,opt,name=upload_at,json=uploadAt,stdtime" json:"upload_at" sql:"default:now()"`
	// Id người tạo tài khoản, Null là người dùng tự đăng ký tài khoản
	UploadBy int32 `protobuf:"varint,5,opt,name=upload_by,json=uploadBy,proto3" json:"upload_by,omitempty"`
	// Ngày gần nhất tài khoản cập nhật thông tin
	ModifiedAt time.Time `protobuf:"bytes,6,opt,name=modified_at,json=modifiedAt,stdtime" json:"modified_at" sql:"default:now()"`
	// Người cập nhật thông tin tài khoản gần nhất
	ModifiedBy int32  `protobuf:"varint,7,opt,name=modified_by,json=modifiedBy,proto3" json:"modified_by,omitempty"`
	Size_      int64  `protobuf:"varint,8,opt,name=size,proto3" json:"size,omitempty"`
	Name       string `protobuf:"bytes,9,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{4} }

func (m *File) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *File) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *File) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *File) GetUploadAt() time.Time {
	if m != nil {
		return m.UploadAt
	}
	return time.Time{}
}

func (m *File) GetUploadBy() int32 {
	if m != nil {
		return m.UploadBy
	}
	return 0
}

func (m *File) GetModifiedAt() time.Time {
	if m != nil {
		return m.ModifiedAt
	}
	return time.Time{}
}

func (m *File) GetModifiedBy() int32 {
	if m != nil {
		return m.ModifiedBy
	}
	return 0
}

func (m *File) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *File) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*EmptyRequest)(nil), "media.EmptyRequest")
	proto.RegisterType((*ResultResponse)(nil), "media.ResultResponse")
	proto.RegisterType((*Pagination)(nil), "media.Pagination")
	proto.RegisterType((*Image)(nil), "media.Image")
	proto.RegisterType((*File)(nil), "media.File")
	proto.RegisterEnum("media.Pagination_Direction", Pagination_Direction_name, Pagination_Direction_value)
}
func (x Pagination_Direction) String() string {
	s, ok := Pagination_Direction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *EmptyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EmptyRequest)
	if !ok {
		that2, ok := that.(EmptyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ResultResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResultResponse)
	if !ok {
		that2, ok := that.(ResultResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *Pagination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Pagination)
	if !ok {
		that2, ok := that.(Pagination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if this.Columns[i] != that1.Columns[i] {
			return false
		}
	}
	if this.OrderByColumn != that1.OrderByColumn {
		return false
	}
	if this.OrderByDirection != that1.OrderByDirection {
		return false
	}
	if this.CurrentPage != that1.CurrentPage {
		return false
	}
	return true
}
func (this *Image) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Image)
	if !ok {
		that2, ok := that.(Image)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Link != that1.Link {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.UploadAt.Equal(that1.UploadAt) {
		return false
	}
	if this.UploadBy != that1.UploadBy {
		return false
	}
	if !this.ModifiedAt.Equal(that1.ModifiedAt) {
		return false
	}
	if this.ModifiedBy != that1.ModifiedBy {
		return false
	}
	return true
}
func (this *File) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*File)
	if !ok {
		that2, ok := that.(File)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.UploadAt.Equal(that1.UploadAt) {
		return false
	}
	if this.UploadBy != that1.UploadBy {
		return false
	}
	if !this.ModifiedAt.Equal(that1.ModifiedAt) {
		return false
	}
	if this.ModifiedBy != that1.ModifiedBy {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *EmptyRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&media.EmptyRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResultResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.ResultResponse{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Pagination) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&media.Pagination{")
	s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	s = append(s, "OrderByColumn: "+fmt.Sprintf("%#v", this.OrderByColumn)+",\n")
	s = append(s, "OrderByDirection: "+fmt.Sprintf("%#v", this.OrderByDirection)+",\n")
	s = append(s, "CurrentPage: "+fmt.Sprintf("%#v", this.CurrentPage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Image) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&media.Image{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Link: "+fmt.Sprintf("%#v", this.Link)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "UploadAt: "+fmt.Sprintf("%#v", this.UploadAt)+",\n")
	s = append(s, "UploadBy: "+fmt.Sprintf("%#v", this.UploadBy)+",\n")
	s = append(s, "ModifiedAt: "+fmt.Sprintf("%#v", this.ModifiedAt)+",\n")
	s = append(s, "ModifiedBy: "+fmt.Sprintf("%#v", this.ModifiedBy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *File) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&media.File{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "UploadAt: "+fmt.Sprintf("%#v", this.UploadAt)+",\n")
	s = append(s, "UploadBy: "+fmt.Sprintf("%#v", this.UploadBy)+",\n")
	s = append(s, "ModifiedAt: "+fmt.Sprintf("%#v", this.ModifiedAt)+",\n")
	s = append(s, "ModifiedBy: "+fmt.Sprintf("%#v", this.ModifiedBy)+",\n")
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringBase(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *EmptyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ResultResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status {
		dAtA[i] = 0x8
		i++
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *Pagination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pagination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.OrderByColumn) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.OrderByColumn)))
		i += copy(dAtA[i:], m.OrderByColumn)
	}
	if m.OrderByDirection != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.OrderByDirection))
	}
	if m.CurrentPage != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CurrentPage))
	}
	return i, nil
}

func (m *Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Id))
	}
	if len(m.Link) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintBase(dAtA, i, uint64(types.SizeOfStdTime(m.UploadAt)))
	n1, err := types.StdTimeMarshalTo(m.UploadAt, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.UploadBy) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.UploadBy)))
		i += copy(dAtA[i:], m.UploadBy)
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintBase(dAtA, i, uint64(types.SizeOfStdTime(m.ModifiedAt)))
	n2, err := types.StdTimeMarshalTo(m.ModifiedAt, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.ModifiedBy) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.ModifiedBy)))
		i += copy(dAtA[i:], m.ModifiedBy)
	}
	return i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Id))
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintBase(dAtA, i, uint64(types.SizeOfStdTime(m.UploadAt)))
	n3, err := types.StdTimeMarshalTo(m.UploadAt, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.UploadBy != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UploadBy))
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintBase(dAtA, i, uint64(types.SizeOfStdTime(m.ModifiedAt)))
	n4, err := types.StdTimeMarshalTo(m.ModifiedAt, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.ModifiedBy != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.ModifiedBy))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Size_))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func encodeVarintBase(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EmptyRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ResultResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func (m *Pagination) Size() (n int) {
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovBase(uint64(l))
		}
	}
	l = len(m.OrderByColumn)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.OrderByDirection != 0 {
		n += 1 + sovBase(uint64(m.OrderByDirection))
	}
	if m.CurrentPage != 0 {
		n += 1 + sovBase(uint64(m.CurrentPage))
	}
	return n
}

func (m *Image) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBase(uint64(m.Id))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = types.SizeOfStdTime(m.UploadAt)
	n += 1 + l + sovBase(uint64(l))
	l = len(m.UploadBy)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = types.SizeOfStdTime(m.ModifiedAt)
	n += 1 + l + sovBase(uint64(l))
	l = len(m.ModifiedBy)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func (m *File) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBase(uint64(m.Id))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = types.SizeOfStdTime(m.UploadAt)
	n += 1 + l + sovBase(uint64(l))
	if m.UploadBy != 0 {
		n += 1 + sovBase(uint64(m.UploadBy))
	}
	l = types.SizeOfStdTime(m.ModifiedAt)
	n += 1 + l + sovBase(uint64(l))
	if m.ModifiedBy != 0 {
		n += 1 + sovBase(uint64(m.ModifiedBy))
	}
	if m.Size_ != 0 {
		n += 1 + sovBase(uint64(m.Size_))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func sovBase(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBase(x uint64) (n int) {
	return sovBase(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *EmptyRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmptyRequest{`,
		`}`,
	}, "")
	return s
}
func (this *ResultResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResultResponse{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Pagination) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Pagination{`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`OrderByColumn:` + fmt.Sprintf("%v", this.OrderByColumn) + `,`,
		`OrderByDirection:` + fmt.Sprintf("%v", this.OrderByDirection) + `,`,
		`CurrentPage:` + fmt.Sprintf("%v", this.CurrentPage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Image) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Image{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Link:` + fmt.Sprintf("%v", this.Link) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`UploadAt:` + strings.Replace(strings.Replace(this.UploadAt.String(), "Timestamp", "google_protobuf1.Timestamp", 1), `&`, ``, 1) + `,`,
		`UploadBy:` + fmt.Sprintf("%v", this.UploadBy) + `,`,
		`ModifiedAt:` + strings.Replace(strings.Replace(this.ModifiedAt.String(), "Timestamp", "google_protobuf1.Timestamp", 1), `&`, ``, 1) + `,`,
		`ModifiedBy:` + fmt.Sprintf("%v", this.ModifiedBy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *File) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&File{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`UploadAt:` + strings.Replace(strings.Replace(this.UploadAt.String(), "Timestamp", "google_protobuf1.Timestamp", 1), `&`, ``, 1) + `,`,
		`UploadBy:` + fmt.Sprintf("%v", this.UploadBy) + `,`,
		`ModifiedAt:` + strings.Replace(strings.Replace(this.ModifiedAt.String(), "Timestamp", "google_protobuf1.Timestamp", 1), `&`, ``, 1) + `,`,
		`ModifiedBy:` + fmt.Sprintf("%v", this.ModifiedBy) + `,`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringBase(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *EmptyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pagination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pagination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pagination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderByColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderByColumn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderByDirection", wireType)
			}
			m.OrderByDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderByDirection |= (Pagination_Direction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPage", wireType)
			}
			m.CurrentPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentPage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := types.StdTimeUnmarshal(&m.UploadAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := types.StdTimeUnmarshal(&m.ModifiedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModifiedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := types.StdTimeUnmarshal(&m.UploadAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadBy", wireType)
			}
			m.UploadBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadBy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := types.StdTimeUnmarshal(&m.ModifiedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedBy", wireType)
			}
			m.ModifiedBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifiedBy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBase(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBase
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBase
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBase
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBase(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBase = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBase   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("base.proto", fileDescriptorBase) }

var fileDescriptorBase = []byte{
	// 546 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x51, 0xb1, 0x6e, 0xdb, 0x3c,
	0x18, 0x14, 0x6d, 0x2b, 0xb1, 0xe9, 0xfc, 0xfe, 0x0d, 0x16, 0x28, 0x04, 0x07, 0xa0, 0x5c, 0x0d,
	0x85, 0x0a, 0xb4, 0x0a, 0x90, 0x6e, 0xd9, 0x2c, 0x27, 0x05, 0xb2, 0x05, 0x4a, 0x87, 0x0e, 0x05,
	0x0c, 0xca, 0xa2, 0x15, 0xa2, 0x92, 0xa8, 0x88, 0x14, 0x0a, 0x75, 0xea, 0x23, 0xe4, 0x31, 0xfa,
	0x02, 0x7d, 0x87, 0x8c, 0x19, 0x3b, 0x04, 0x69, 0xad, 0x2e, 0x1d, 0x83, 0x3e, 0x41, 0x21, 0x4a,
	0xb2, 0x33, 0x74, 0xeb, 0x90, 0xed, 0xbe, 0xe3, 0xe9, 0xbe, 0xd3, 0x7d, 0x10, 0xfa, 0x44, 0x50,
	0x27, 0xcd, 0xb8, 0xe4, 0x48, 0x8f, 0x69, 0xc0, 0xc8, 0xe4, 0x55, 0xc8, 0xe4, 0x45, 0xee, 0x3b,
	0x4b, 0x1e, 0x1f, 0x84, 0x3c, 0xe4, 0x07, 0xea, 0xd5, 0xcf, 0x57, 0x6a, 0x52, 0x83, 0x42, 0xf5,
	0x57, 0x13, 0x33, 0xe4, 0x3c, 0x8c, 0xe8, 0x56, 0x25, 0x59, 0x4c, 0x85, 0x24, 0x71, 0x5a, 0x0b,
	0xac, 0x11, 0xdc, 0x3b, 0x89, 0x53, 0x59, 0x78, 0xf4, 0x32, 0xa7, 0x42, 0x5a, 0x2e, 0x1c, 0x79,
	0x54, 0xe4, 0x91, 0xf4, 0xa8, 0x48, 0x79, 0x22, 0x28, 0x7a, 0x0a, 0x77, 0x84, 0x24, 0x32, 0x17,
	0x06, 0x98, 0x02, 0xbb, 0xef, 0x35, 0x13, 0x32, 0xe0, 0x6e, 0x4c, 0x85, 0x20, 0x21, 0x35, 0x3a,
	0x53, 0x60, 0x0f, 0xbc, 0x76, 0xb4, 0x6e, 0x01, 0x84, 0x67, 0x24, 0x64, 0x09, 0x91, 0x8c, 0x27,
	0x95, 0x70, 0xc9, 0xa3, 0x3c, 0x4e, 0x2a, 0x87, 0x6e, 0x25, 0x6c, 0x46, 0xf4, 0x1c, 0xfe, 0xcf,
	0xb3, 0x80, 0x66, 0x0b, 0xbf, 0x58, 0xd4, 0x5c, 0x63, 0xf5, 0x9f, 0xa2, 0xdd, 0x62, 0xae, 0x48,
	0x74, 0x0a, 0xd1, 0x46, 0x17, 0xb0, 0x8c, 0x2e, 0x2b, 0x5f, 0xa3, 0x3b, 0x05, 0xf6, 0xe8, 0x70,
	0xdf, 0x51, 0xc5, 0x38, 0xdb, 0x85, 0xce, 0x71, 0x2b, 0xf1, 0xc6, 0x8d, 0xcf, 0x86, 0x41, 0xcf,
	0xe0, 0xde, 0x32, 0xcf, 0x32, 0x9a, 0xc8, 0x45, 0x5a, 0x45, 0xef, 0x4d, 0x81, 0xad, 0x7b, 0xc3,
	0x86, 0x3b, 0xab, 0xe2, 0x63, 0x38, 0xd8, 0xea, 0x77, 0x61, 0x77, 0x76, 0x3e, 0x1f, 0x6b, 0xa8,
	0x0f, 0x7b, 0xc7, 0x27, 0xe7, 0xf3, 0x31, 0xb0, 0xbe, 0x76, 0xa0, 0x7e, 0x1a, 0x93, 0x90, 0xa2,
	0x11, 0xec, 0xb0, 0x40, 0xd5, 0xa2, 0x7b, 0x1d, 0x16, 0x20, 0x04, 0x7b, 0x11, 0x4b, 0x3e, 0x34,
	0x3f, 0xa1, 0x70, 0xc5, 0xc9, 0x22, 0xa5, 0x2a, 0xed, 0xc0, 0x53, 0x18, 0xbd, 0x83, 0x83, 0x3c,
	0x8d, 0x38, 0x09, 0x16, 0x44, 0xaa, 0x04, 0xc3, 0xc3, 0x89, 0x53, 0x5f, 0xca, 0x69, 0x2f, 0xe5,
	0xbc, 0x6d, 0x2f, 0xe5, 0x9a, 0xd7, 0x77, 0xa6, 0xf6, 0xfb, 0xce, 0x7c, 0x22, 0x2e, 0xa3, 0x23,
	0x2b, 0xa0, 0x2b, 0x92, 0x47, 0xf2, 0x28, 0xe1, 0x1f, 0xed, 0x17, 0xd6, 0xd5, 0x77, 0x13, 0x78,
	0xfd, 0xda, 0x6d, 0x26, 0xd1, 0xfe, 0xc6, 0xd9, 0x2f, 0x0c, 0x5d, 0xad, 0x6c, 0x1e, 0xdd, 0x02,
	0xbd, 0x87, 0xc3, 0x98, 0x07, 0x6c, 0xc5, 0xa8, 0x5a, 0xbc, 0xf3, 0xef, 0x8b, 0x61, 0xeb, 0x37,
	0x93, 0xc8, 0x7c, 0xe0, 0xee, 0x17, 0xc6, 0xae, 0x5a, 0xbe, 0x11, 0xb8, 0x85, 0x75, 0xdb, 0x81,
	0xbd, 0x37, 0x2c, 0xfa, 0x6b, 0x6d, 0x29, 0x91, 0x17, 0x6d, 0x6d, 0x15, 0x7e, 0xec, 0xda, 0xf4,
	0xc7, 0xac, 0x4d, 0x7f, 0x58, 0x5b, 0xd5, 0x84, 0x60, 0x9f, 0xa8, 0xd1, 0x9f, 0x02, 0xbb, 0xeb,
	0x29, 0x5c, 0x71, 0x09, 0x89, 0xa9, 0x31, 0xa8, 0xdb, 0xa9, 0xb0, 0xfb, 0xf2, 0x66, 0x8d, 0xb5,
	0x6f, 0x6b, 0xac, 0xdd, 0xaf, 0x31, 0xf8, 0x5c, 0x62, 0xf0, 0xa5, 0xc4, 0xe0, 0xba, 0xc4, 0xe0,
	0xa6, 0xc4, 0xe0, 0x47, 0x89, 0xc1, 0xaf, 0x12, 0x6b, 0xf7, 0x25, 0x06, 0x57, 0x3f, 0xb1, 0xe6,
	0xef, 0xa8, 0xdc, 0xaf, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xe1, 0xee, 0x51, 0x7d, 0x63, 0x04,
	0x00, 0x00,
}
